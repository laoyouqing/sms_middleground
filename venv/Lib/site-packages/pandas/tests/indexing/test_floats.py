from warnings import catch_warnings

import numpy as np
import pytest

from pandas import DataFrame, Float64Index, Index, Int64Index, RangeIndex, Series
import pandas.util.testing as tm
from pandas.util.testing import assert_almost_equal, assert_series_equal

ignore_ix = pytest.mark.filterwarnings("ignore:\\n.ix:FutureWarning")


class TestFloatIndexers:
    def check(self, result, original, indexer, getitem):
        """
        comparator for results
        we need to take care if we are indexing on a
        Series or a frame
        """
        if isinstance(original, Series):
            expected = original.iloc[indexer]
        else:
            if getitem:
                expected = original.iloc[:, indexer]
            else:
                expected = original.iloc[indexer]

        assert_almost_equal(result, expected)

    def test_scalar_error(self):

        # GH 4892
        # float_indexers should raise exceptions
        # on appropriate Index types & accessors
        # this duplicates the code below
        # but is specifically testing for the error
        # message

        for index in [
            tm.makeStringIndex,
            tm.makeUnicodeIndex,
            tm.makeCategoricalIndex,
            tm.makeDateIndex,
            tm.makeTimedeltaIndex,
            tm.makePeriodIndex,
            tm.makeIntIndex,
            tm.makeRangeIndex,
        ]:

            i = index(5)

            s = Series(np.arange(len(i)), index=i)

            msg = "Cannot index by location index"
            with pytest.raises(TypeError, match=msg):
                s.iloc[3.0]

            msg = (
                "cannot do positional indexing on {klass} with these "
                r"indexers \[3\.0\] of {kind}".format(klass=type(i), kind=str(float))
            )
            with pytest.raises(TypeError, match=msg):
                s.iloc[3.0] = 0

    @ignore_ix
    def test_scalar_non_numeric(self):

        # GH 4892
        # float_indexers should raise exceptions
        # on appropriate Index types & accessors

        for index in [
            tm.makeStringIndex,
            tm.makeUnicodeIndex,
            tm.makeCategoricalIndex,
            tm.makeDateIndex,
            tm.makeTimedeltaIndex,
            tm.makePeriodIndex,
        ]:

            i = index(5)

            for s in [
                Series(np.arange(len(i)), index=i),
                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
            ]:

                # getting
                for idxr, getitem in [
                    (lambda x: x.ix, False),
                    (lambda x: x.iloc, False),
                    (lambda x: x, True),
                ]:

                    # gettitem on a DataFrame is a KeyError as it is indexing
                    # via labels on the columns
                    if getitem and isinstance(s, DataFrame):
                        error = KeyError
                        msg = r"^3(\.0)?$"
                    else:
                        error = TypeError
                        msg = (
                            r"cannot do (label|index|positional) indexing"
                            r" on {klass} with these indexers \[3\.0\] of"
                            r" {kind}|"
                            "Cannot index by location index with a"
                            " non-integer key".format(klass=type(i), kind=str(float))
                        )
                    with catch_warnings(record=True):
                        with pytest.raises(error, match=msg):
                            idxr(s)[3.0]

                # label based can be a TypeError or KeyError
                if s.index.inferred_type in ["string", "unicode", "mixed"]:
                    error = KeyError
                    msg = r"^3$"
                else:
                    error = TypeError
                    msg = (
                        r"cannot do (label|index) indexing"
                        r" on {klass} with these indexers \[3\.0\] of"
                        r" {kind}".format(klass=type(i), kind=str(float))
                    )
                with pytest.raises(error, match=msg):
                    s.loc[3.0]

                # contains
                assert 3.0 not in s

                # setting with a float fails with iloc
                msg = (
                    r"cannot do (label|index|positional) indexing"
                    r" on {klass} with these indexers \[3\.0\] of"
                    r" {kind}".format(klass=type(i), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    s.iloc[3.0] = 0

                # setting with an indexer
                if s.index.inferred_type in ["categorical"]:
                    # Value or Type Error
                    pass
                elif s.index.inferred_type in ["datetime64", "timedelta64", "period"]:

                    # these should prob work
                    # and are inconsisten between series/dataframe ATM
                    # for idxr in [lambda x: x.ix,
                    #             lambda x: x]:
                    #    s2 = s.copy()
                    #
                    #    with pytest.raises(TypeError):
                    #        idxr(s2)[3.0] = 0
                    pass

                else:

                    s2 = s.copy()
                    s2.loc[3.0] = 10
                    assert s2.index.is_object()

                    for idxr in [lambda x: x.ix, lambda x: x]:
                        s2 = s.copy()
                        with catch_warnings(record=True):
                            idxr(s2)[3.0] = 0
                        assert s2.index.is_object()

            # fallsback to position selection, series only
            s = Series(np.arange(len(i)), index=i)
            s[3]
            msg = (
                r"cannot do (label|index) indexing"
                r" on {klass} with these indexers \[3\.0\] of"
                r" {kind}".format(klass=type(i), kind=str(float))
            )
            with pytest.raises(TypeError, match=msg):
                s[3.0]

    @ignore_ix
    def test_scalar_with_mixed(self):

        s2 = Series([1, 2, 3], index=["a", "b", "c"])
        s3 = Series([1, 2, 3], index=["a", "b", 1.5])

        # lookup in a pure stringstr
        # with an invalid indexer
        for idxr in [lambda x: x.ix, lambda x: x, lambda x: x.iloc]:

            msg = (
                r"cannot do label indexing"
                r" on {klass} with these indexers \[1\.0\] of"
                r" {kind}|"
                "Cannot index by location index with a non-integer key".format(
                    klass=str(Index), kind=str(float)
                )
            )
            with catch_warnings(record=True):
                with pytest.raises(TypeError, match=msg):
                    idxr(s2)[1.0]

        with pytest.raises(KeyError, match=r"^1$"):
            s2.loc[1.0]

        result = s2.loc["b"]
        expected = 2
        assert result == expected

        # mixed index so we have label
        # indexing
        for idxr in [lambda x: x]:

            msg = (
                r"cannot do label indexing"
                r" on {klass} with these indexers \[1\.0\] of"
                r" {kind}".format(klass=str(Index), kind=str(float))
            )
            with pytest.raises(TypeError, match=msg):
                idxr(s3)[1.0]

            result = idxr(s3)[1]
            expected = 2
            assert result == expected

        # mixed index so we have label
        # indexing
        for idxr in [lambda x: x.ix]:
            with catch_warnings(record=True):

                msg = (
                    r"cannot do label indexing"
                    r" on {klass} with these indexers \[1\.0\] of"
                    r" {kind}".format(klass=str(Index), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    idxr(s3)[1.0]

                result = idxr(s3)[1]
                expected = 2
                assert result == expected

        msg = "Cannot index by location index with a non-integer key"
        with pytest.raises(TypeError, match=msg):
            s3.iloc[1.0]
        with pytest.raises(KeyError, match=r"^1$"):
            s3.loc[1.0]

        result = s3.loc[1.5]
        expected = 3
        assert result == expected

    @ignore_ix
    def test_scalar_integer(self):

        # test how scalar float indexers work on int indexes

        # integer index
        for i in [Int64Index(range(5)), RangeIndex(5)]:

            for s in [
                Series(np.arange(len(i))),
                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
            ]:

                # coerce to equal int
                for idxr, getitem in [
                    (lambda x: x.ix, False),
                    (lambda x: x.loc, False),
                    (lambda x: x, True),
                ]:

                    with catch_warnings(record=True):
                        result = idxr(s)[3.0]
                    self.check(result, s, 3, getitem)

                # coerce to equal int
                for idxr, getitem in [
                    (lambda x: x.ix, False),
                    (lambda x: x.loc, False),
                    (lambda x: x, True),
                ]:

                    if isinstance(s, Series):

                        def compare(x, y):
                            assert x == y

                        expected = 100
                    else:
                        compare = tm.assert_series_equal
                        if getitem:
                            expected = Series(100, index=range(len(s)), name=3)
                        else:
                            expected = Series(100.0, index=range(len(s)), name=3)

                    s2 = s.copy()
                    with catch_warnings(record=True):
                        idxr(s2)[3.0] = 100

                        result = idxr(s2)[3.0]
                        compare(result, expected)

                        result = idxr(s2)[3]
                        compare(result, expected)

                # contains
                # coerce to equal int
                assert 3.0 in s

    @ignore_ix
    def test_scalar_float(self):

        # scalar float indexers work on a float index
        index = Index(np.arange(5.0))
        for s in [
            Series(np.arange(len(index)), index=index),
            DataFrame(
                np.random.randn(len(index), len(index)), index=index, columns=index
            ),
        ]:

            # assert all operations except for iloc are ok
            indexer = index[3]
            for idxr, getitem in [
                (lambda x: x.ix, False),
                (lambda x: x.loc, False),
                (lambda x: x, True),
            ]:

                # getting
                result = idxr(s)[indexer]
                self.check(result, s, 3, getitem)

                # setting
                s2 = s.copy()

                with catch_warnings(record=True):
                    result = idxr(s2)[indexer]
                self.check(result, s, 3, getitem)

                # random integer is a KeyError
                with catch_warnings(record=True):
                    with pytest.raises(KeyError, match=r"^3\.5$"):
                        idxr(s)[3.5]

            # contains
            assert 3.0 in s

            # iloc succeeds with an integer
            expected = s.iloc[3]
            s2 = s.copy()

            s2.iloc[3] = expected
            result = s2.iloc[3]
            self.check(result, s, 3, False)

            # iloc raises with a float
            msg = "Cannot index by location index with a non-integer key"
            with pytest.raises(TypeError, match=msg):
                s.iloc[3.0]

            msg = (
                r"cannot do positional indexing"
                r" on {klass} with these indexers \[3\.0\] of"
                r" {kind}".format(klass=str(Float64Index), kind=str(float))
            )
            with pytest.raises(TypeError, match=msg):
                s2.iloc[3.0] = 0

    @ignore_ix
    def test_slice_non_numeric(self):

        # GH 4892
        # float_indexers should raise exceptions
        # on appropriate Index types & accessors

        for index in [
            tm.makeStringIndex,
            tm.makeUnicodeIndex,
            tm.makeDateIndex,
            tm.makeTimedeltaIndex,
            tm.makePeriodIndex,
        ]:

            index = index(5)
            for s in [
                Series(range(5), index=index),
                DataFrame(np.random.randn(5, 2), index=index),
            ]:

                # getitem
                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                    msg = (
                        "cannot do slice indexing"
                        r" on {klass} with these indexers \[(3|4)\.0\] of"
                        " {kind}".format(klass=type(index), kind=str(float))
                    )
                    with pytest.raises(TypeError, match=msg):
                        s.iloc[l]

                    for idxr in [
                        lambda x: x.ix,
                        lambda x: x.loc,
                        lambda x: x.iloc,
                        lambda x: x,
                    ]:

                        msg = (
                            "cannot do slice indexing"
                            r" on {klass} with these indexers"
                            r" \[(3|4)(\.0)?\]"
                            r" of ({kind_float}|{kind_int})".format(
                                klass=type(index),
                                kind_float=str(float),
                                kind_int=str(int),
                            )
                        )
                        with catch_warnings(record=True):
                            with pytest.raises(TypeError, match=msg):
                                idxr(s)[l]

                # setitem
                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                    msg = (
                        "cannot do slice indexing"
                        r" on {klass} with these indexers \[(3|4)\.0\] of"
                        " {kind}".format(klass=type(index), kind=str(float))
                    )
                    with pytest.raises(TypeError, match=msg):
                        s.iloc[l] = 0

                    for idxr in [
                        lambda x: x.ix,
                        lambda x: x.loc,
                        lambda x: x.iloc,
                        lambda x: x,
                    ]:
                        msg = (
                            "cannot do slice indexing"
                            r" on {klass} with these indexers"
                            r" \[(3|4)(\.0)?\]"
                            r" of ({kind_float}|{kind_int})".format(
                                klass=type(index),
                                kind_float=str(float),
                                kind_int=str(int),
                            )
                        )
                        with catch_warnings(record=True):
                            with pytest.raises(TypeError, match=msg):
                                idxr(s)[l] = 0

    @ignore_ix
    def test_slice_integer(self):

        # same as above, but for Integer based indexes
        # these coerce to a like integer
        # oob indicates if we are out of bounds
        # of positional indexing
        for index, oob in [
            (Int64Index(range(5)), False),
            (RangeIndex(5), False),
            (Int64Index(range(5)) + 10, True),
        ]:

            # s is an in-range index
            s = Series(range(5), index=index)

            # getitem
            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                for idxr in [lambda x: x.loc, lambda x: x.ix]:

                    with catch_warnings(record=True):
                        result = idxr(s)[l]

                    # these are all label indexing
                    # except getitem which is positional
                    # empty
                    if oob:
                        indexer = slice(0, 0)
                    else:
                        indexer = slice(3, 5)
                    self.check(result, s, indexer, False)

                # positional indexing
                msg = (
                    "cannot do slice indexing"
                    r" on {klass} with these indexers \[(3|4)\.0\] of"
                    " {kind}".format(klass=type(index), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    s[l]

            # getitem out-of-bounds
            for l in [slice(-6, 6), slice(-6.0, 6.0)]:

                for idxr in [lambda x: x.loc, lambda x: x.ix]:
                    with catch_warnings(record=True):
                        result = idxr(s)[l]

                    # these are all label indexing
                    # except getitem which is positional
                    # empty
                    if oob:
                        indexer = slice(0, 0)
                    else:
                        indexer = slice(-6, 6)
                    self.check(result, s, indexer, False)

            # positional indexing
            msg = (
                "cannot do slice indexing"
                r" on {klass} with these indexers \[-6\.0\] of"
                " {kind}".format(klass=type(index), kind=str(float))
            )
            with pytest.raises(TypeError, match=msg):
                s[slice(-6.0, 6.0)]

            # getitem odd floats
            for l, res1 in [
                (slice(2.5, 4), slice(3, 5)),
                (slice(2, 3.5), slice(2, 4)),
                (slice(2.5, 3.5), slice(3, 4)),
            ]:

                for idxr in [lambda x: x.loc, lambda x: x.ix]:

                    with catch_warnings(record=True):
                        result = idxr(s)[l]
                    if oob:
                        res = slice(0, 0)
                    else:
                        res = res1

                    self.check(result, s, res, False)

                # positional indexing
                msg = (
                    "cannot do slice indexing"
                    r" on {klass} with these indexers \[(2|3)\.5\] of"
                    " {kind}".format(klass=type(index), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    s[l]

            # setitem
            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                for idxr in [lambda x: x.loc, lambda x: x.ix]:
                    sc = s.copy()
                    with catch_warnings(record=True):
                        idxr(sc)[l] = 0
                        result = idxr(sc)[l].values.ravel()
                    assert (result == 0).all()

                # positional indexing
                msg = (
                    "cannot do slice indexing"
                    r" on {klass} with these indexers \[(3|4)\.0\] of"
                    " {kind}".format(klass=type(index), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    s[l] = 0

    def test_integer_positional_indexing(self):
        """ make sure that we are raising on positional indexing
        w.r.t. an integer index """

        s = Series(range(2, 6), index=range(2, 6))

        result = s[2:4]
        expected = s.iloc[2:4]
        assert_series_equal(result, expected)

        for idxr in [lambda x: x, lambda x: x.iloc]:

            for l in [slice(2, 4.0), slice(2.0, 4), slice(2.0, 4.0)]:

                klass = RangeIndex
                msg = (
                    "cannot do slice indexing"
                    r" on {klass} with these indexers \[(2|4)\.0\] of"
                    " {kind}".format(klass=str(klass), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    idxr(s)[l]

    @ignore_ix
    def test_slice_integer_frame_getitem(self):

        # similar to above, but on the getitem dim (of a DataFrame)
        for index in [Int64Index(range(5)), RangeIndex(5)]:

            s = DataFrame(np.random.randn(5, 2), index=index)

            def f(idxr):

                # getitem
                for l in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:

                    result = idxr(s)[l]
                    indexer = slice(0, 2)
                    self.check(result, s, indexer, False)

                    # positional indexing
                    msg = (
                        "cannot do slice indexing"
                        r" on {klass} with these indexers \[(0|1)\.0\] of"
                        " {kind}".format(klass=type(index), kind=str(float))
                    )
                    with pytest.raises(TypeError, match=msg):
                        s[l]

                # getitem out-of-bounds
                for l in [slice(-10, 10), slice(-10.0, 10.0)]:

                    result = idxr(s)[l]
                    self.check(result, s, slice(-10, 10), True)

                # positional indexing
                msg = (
                    "cannot do slice indexing"
                    r" on {klass} with these indexers \[-10\.0\] of"
                    " {kind}".format(klass=type(index), kind=str(float))
                )
                with pytest.raises(TypeError, match=msg):
                    s[slice(-10.0, 10.0)]

                # getitem odd floats
                for l, res in [
                    (slice(0.5, 1), slice(1, 2)),
                    (slice(0, 0.5), slice(0, 1)),
                    (slice(0.5, 1.5), slice(1, 2)),
                ]:

                    result = idxr(s)[l]
                    self.check(result, s, res, False)

                    # positional indexing
                    msg = (
                        "cannot do slice indexing"
                        r" on {klass} with these indexers \[0\.5\] of"
                        " {kind}".format(klass=type(index), kind=str(float))
                    )
                    with pytest.raises(TypeError, match=msg):
                        s[l]

                # setitem
                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                    sc = s.copy()
                    idxr(sc)[l] = 0
                    result = idxr(sc)[l].values.ravel()
                    assert (result == 0).all()

                    # positional indexing
                    msg = (
                        "cannot do slice indexing"
                        r" on {klass} with these indexers \[(3|4)\.0\] of"
                        " {kind}".format(klass=type(index), kind=str(float))
                    )
                    with pytest.raises(TypeError, match=msg):
                        s[l] = 0

            f(lambda x: x.loc)
            with catch_warnings(record=True):
                f(lambda x: x.ix)

    @ignore_ix
    def test_slice_float(self):

        # same as above, but for floats
        index = Index(np.arange(5.0)) + 0.1
        for s in [
            Series(range(5), index=index),
            DataFrame(np.random.randn(5, 2), index=index),
        ]:

            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:

                expected = s.iloc[3:4]
                for idxr in [lambda x: x.ix, lambda x: x.loc, lambda x: x]:

                    # getitem
                    with catch_warnings(record=True):
                        result = idxr(s)[l]
                    if isinstance(s, Series):
                        tm.assert_series_equal(result, expected)
                    else:
                        tm.assert_frame_equal(result, expected)
                    # setitem
                    s2 = s.copy()
                    with catch_warnings(record=True):
                        idxr(s2)[l] = 0
                        result = idxr(s2)[l].values.ravel()
                    assert (result == 0).all()

    def test_floating_index_doc_example(self):

        index = Index([1.5, 2, 3, 4.5, 5])
        s = Series(range(5), index=index)
        assert s[3] == 2
        assert s.loc[3] == 2
        assert s.loc[3] == 2
        assert s.iloc[3] == 3

    def test_floating_misc(self):

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        